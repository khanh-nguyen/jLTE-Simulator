# jLTE Simulator

## Overview 

The jLTE Simulator is a network simulator designed to simulate the
physical layer of an LTE network consisting of a number of base
stations (eNodeBs) and users (UEs). It was designed specifically for
the research project investigating the effect of co-ordinated
scheduling in LTE networks. Further documentation is included within
the thesis itself which is availabe at [downthewire.co.uk][1].

## Getting Started 
This project was built using Apache Maven which can be downloaded from 
[maven.apache.org][2] and installed by following the instructions on that 
page.

Before the system can be fully compiled Michael Thomas Flanagan's Java 
Scientific Library must be installed. The jar file must be downloaded 
and installed into your local maven repository. This can be achieved using
the following commands:

`wget http://www.ee.ucl.ac.uk/~mflanaga/java/flanagan.jar`

`mvn install:install-file -Dfile=flanagan.jar -DgroupId=flanagan -DartifactId=flanagan -Dversion=1.0 -Dpackaging=jar`

The project can then be compiled in the same fashion as any maven
project using the following command:

`mvn compile`


### Generating Fading Data 

In order to use the simulator run the tests some auxiliary fading data
must be generated. This data is used to model the signal quality of
the wireless channel between each user and base station. The location
of the fading data is specified in the `lte.fadingPath` configuration
option in the `system.properties` config file which can be found in
the `src/main/resources/` directory.

The fading data can be generated by running the `GenerateFading` main
class in the package `uk.co.downthewire.jLTE.fading`. This can be 
executed in maven using the command 'mvn exec:java'. Note that significant 
heap space can be required to generate adequate fading data.

### Running Tests

Having generated the fading data required the tests can now be run
using the standard maven command:

`mvn test`

The test suite includes both unit and integration tests which will
take ~10 minutes to complete.

### Running the Simulator

Now that the tests are all passing you can begin to run your own
network scenarios. Some example scenarios are defined as part of the
test suite, see the `src/test/resources/` directory. Each scenario
contains a config file for the UEs and a config file for the eNodeBs.
A number of settings are also defined in the `system.properties`
configuration file. 

## Change log
* *ResourceBlock.java* : 
** separate data rate, sinr, avargae sinr by UL and DL. 
** Create Comparator: `RB_UL_SINR_COMPARATOR` and `RB_DL_SINR_COMPARATOR` // FIXME: do we really need these?
** Keep Comparator: `RB_SINR_COMPARATOR`

* *AbstractSector.java* : 
** separate DatarateCounter, 
** rename `assignDownlinkRBs` to `assignRBs`, 
** rename `doDownlinkAllocation` to `allocateRB` 
** change `getUEsToSchedule()` to `getUEsToSchedule(boolean isDL)`
** change `allocateRBToUE(UE ue, ResourceBlock RB)` to `allocateRBToUE(UE ue, ResourceBlock RB, boolean isDL)` 
** `accumulateDatarate()` updates both `ulDatarateCounter` and `dlDatarateCounter`  // Does this make the statistics inaccurate? Answer: this should work as we update datarate for UE in both UL and DL in each iteration.
** add `getAvgUplinkTput()`
** change `getPercentileTput` to `getPercentileULTput()` and `getPercentileDLTput`
** add `setFrameConfiguration(int dlSubframes)` used for UL/DL scheduling
** add `isDownlinkSubframe(int subframe)` to check if the current `subframe` is scheduled for UL or DL. 
** NOTE: in `generateX2Requests(int iteration)`, we use `ResourceBlock.RB_SINR_COMPARATOR`. Is it correct?

* *AdaptiveSFRSector* 
** `determineEdgeUEs()` uses `ue.getAverageSinr(true) + ue.getAverageSinr(false)` 
** change `randomDownlinkAllocation(final int iteration)` to `randomRBAllocation(final int iteration, final int subframe)`

* *DistributedSFRSector*
** `priorDatarate = getPercentileULTput() + getPercentileDLTput()`

* *MaxCISector*
** change `allocateRB(final int iteration)` to `allocateRB(final int iteration, final int subframe)`.

* *ProportionateFairSector*
** change `allocateRB(final int iteration)` to `allocateRB(final int iteration, final int subframe)`. 

* *RandomSector*
** change `allocateRB(final int iteration)` to `allocateRB(final int iteration, final int subframe)`. 

* *SFRSector*
** change `allocateRB(final int iteration)` to `allocateRB(final int iteration, final int subframe)`.
** change `getPriorityComparator(final ResourceBlock RB)` to `getPriorityComparator(final ResourceBlock RB, final boolean isDL)`.
** change `calculatePriority(UE ue, ResourceBlock rb)` to `calculatePriority(UE ue, ResourceBlock rb, boolean isDL)`.

* *SerFRSector* (extends from `SFRSector`)
** change `allocateRB(final int iteration)` to `allocateRB(final int iteration, final int subframe)`.
** change `calculatePriority(UE ue, ResourceBlock rb)` to `calculatePriority(UE ue, ResourceBlock rb, boolean isDL)`.

* *TrafficGenerator*
** change `public double getDownlinkProb(TrafficType trafficType)` to `private double getTrafficProb(TrafficType trafficType)`.

* *UE*
** change `scheduledRBs` to `scheduledULRBs` and `scheduledDLRBs`.
** change `currentRBsQueued` to `currentULRBsQueued` and `currentDLRBsQueued`.
** change `totalDatarates` to `totalULDatarates` and `totalDLDatarates`.
** change `totalSinr` to `totalULSinr` and `totalDLSinr`.
** change `totalRBsServed` to `ulRBsServed` and `dlRBsServed`.
** change `totalRBsQueued` to `ulRBsQueued` and `dlRBsQueued`.
** change `signalPerRB` to `signalPerULRB` and `signalPerDLRB`.
** add `txPower`, used for calculating uplink power.
** update `resetScheduledStatus()` to clear `scheduledULRBs` and `scheduledDLRBs`.
** update `generateTraffic(double random)`: the `numRBs` us generated as normal, but it's added to UL or DL queued based on the `TRAFFIC_UPLINK_PROB`.
** change `schedule(ResourceBlock RB)` to `schedule(ResourceBlock RB, boolean isDL)` to update the appropriate current queue, reserved RBs and scheduled RBs.
** update `calculateSignalAcrossAllRBs()` to calculate uplink and downlink signal for each RB.
** change `getSignalOnRB(int RB)` to `getSignalOnRB(int RB, boolean isDL)` to get last sample of UL/DL signal.
** change `getRelativeSignalOnRB(int RB)` to `getRelativeSignalOnRB(int RB, boolean isDL)` to get relative UL/DL signal.
** change `getAverageSinr()` to `getAverageSinr(boolean isDL)` to separate average SINR by UL and DL.
** change `accumulateDatarate()` to `accumulateDatarate(int subframe)` to separate UL and DL datarate. Note that `subframe` is used in calculating interference.
** change `calculateSignal(ResourceBlock RB)` to `calculateSignal(ResourceBlock RB, boolean isDL)`.
** change `calculateInterference(ResourceBlock RB)` to `calculateInterference(ResourceBlock RB, int subframe)`. !!!! FIXME !!!!

* *UEComparator*
** change `Comparator<UE> getRBSignalComparator(final int RB)` to `Comparator<UE> getRBSignalComparator(final int RB, final boolean isDL)`. This method is used to sort UE by their scheduled traffic (MaxCISector).
** change `Comparator<UE> getRelativeSignalComparator(final int RB)` to `Comparator<UE> getRelativeSignalComparator(final int RB, final boolean isDL)`. This method is used in `ProportionateFairSector`.

* *UESectorTuple* 
** TODO: verify meaning of gamma, model for computing DL gain, UL gain, what's their meaning? 
** add `getUplinkPower(RB)`
** add `getPower(ResourceBlock RB, int subframe)`
** add `uplinkGain` and `txPowerPerRBUL`


## License

Copyright (C) 2013 Andrew Thompson

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



[1]:http://downthewire.co.uk/
[2]:http://maven.apache.org/download.cgi
